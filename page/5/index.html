<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小象のblog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="小象のblog">
<meta property="og:url" content="https://xiaoxiangxiong.gitee.io/page/5/index.html">
<meta property="og:site_name" content="小象のblog">
<meta property="og:description" content="记录学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="小象">
<meta property="article:tag" content="xiaoxiang,小象のblog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小象のblog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="mheader">
    <div class="mtitle-wrap">
        <a href="/" class="mtitle">小象のblog</a>
		<a href="/archives/" class="msubtitle">概览</a>
		<a href="http://xiaoxiang.space" target="_self" class="msubtitle">说点什么</a>
    </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-垃圾回收器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/30/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="article-date">
  <time datetime="2020-09-30T07:07:07.000Z" itemprop="datePublished">2020-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/30/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">垃圾回收器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>-XX:+PrintCommandLineFlags</strong>：查看命令行参数（可打印出使用的是哪个垃圾回收器）。</p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/3.jpg" alt="垃圾收集器"></p>
<h3 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h3><ul>
<li><p>Client模式下默认的新生代垃圾收集器。</p>
</li>
<li><p>Serial收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</p>
</li>
<li><p>Serial Old-对应的老年代垃圾收集器，同样采用串行回收和“Stop-The-World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>Serial Old是Client模式下默认的老年代的垃圾收集器。</li>
<li>Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用；②作为老年代CMS收集器的后备垃圾收集方案。</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，在它进行垃圾收集时，必须停掉其他所有的工作线程，直到它收集结束。</p>
</li>
<li><p>-XX:+UseSerialGC：指定新生代Serial，老年代Serial Old GC。</p>
</li>
</ul>
<h3 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h3><ul>
<li><p>多线程的Serial。</p>
</li>
<li><p>-XX:+UseParNewGC：指定年轻代ParNew，不影响老年代。</p>
</li>
<li><p>-XX:ParallelGCThreads：限制线程数量，默认开启与cpu数据相同的线程数。</p>
</li>
</ul>
<h3 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h3><ul>
<li><p>同样采用并行回收、复制算法、STW机制。</p>
</li>
<li><p>Parallel Scavenge收集器的目标是达到一个可控的吞吐量，它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节机制也是Parallel Scavenge与ParNew的一个重要区别。</p>
</li>
<li><p>高吞吐量可以高效的利用cpu时间，尽快的完成程序的运算任务。<strong>主要用于在后台运算而不需要太多交互的任务</strong>。</p>
</li>
<li><p>应用场景：执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel Old：老年代垃圾收集器，采用标记-压缩算法、并行回收、STW机制。</p>
</li>
<li><p>-XX:+UseParallelGC：手动指定年轻代使用Parallel；-XX:+UserParallelOldGC：手动指定老年代。这两个参数，当指定一个，另一个也会被开启。</p>
</li>
<li><p>-XX:ParallelGCThreads：设置年轻代并行的线程数。</p>
</li>
<li><p>-XX:+UseAdaptiveSizePolicy：设置Parallel收集器具有自适应调节策列。</p>
</li>
</ul>
<h3 id="CMS回收器：低延迟-Concurrent-Mark-Sweep"><a href="#CMS回收器：低延迟-Concurrent-Mark-Sweep" class="headerlink" title="CMS回收器：低延迟(Concurrent-Mark-Sweep)"></a>CMS回收器：低延迟(Concurrent-Mark-Sweep)</h3><ul>
<li><p>HotSpot虚拟机中第一款真正意义上的并发收集器，实现了让垃圾收集线程与用户线程同时执行。</p>
</li>
<li><p>采用标记清除算法，也会导致stw。</p>
</li>
<li><p>运行过程：</p>
<ul>
<li>初始标记：仅标记GC Roots能直接关联到的对象。速度很快，需要stw。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程。</li>
<li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的stw一般会比初始标记稍长一些。</li>
<li>并发清除：清理标记阶段判断已经死亡的对象，释放内存空间。这个阶段可与用户线程并发。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/2.jpg" alt="cms"></p>
<ul>
<li><p>由于在垃圾收集阶段用户线程仍在执行，所以在<strong>CMS回收过程中，要保证应用程序线程有足够的内存可用</strong>。因此，CMS收集器不能像别的收集器一样等到老年代几乎完全填满了才进行垃圾回收，而是在堆内存达到某一个阈值时，便开始进行回收。当CMS运行期间，内存无法满足程序要求，这时虚拟机会启用预备方案：临时使用Serial Old进行垃圾回收。</p>
</li>
<li><p>CMS采用标记-清除算法，只能采用空闲列表进行内存分配。</p>
</li>
<li><p>优点：低延迟，并发收集。</p>
</li>
<li><p>缺点：产生内存碎片；对cpu资源非常敏感，因为占用了一部分线程，会导致吞吐量降低；无法处理浮动垃圾（并发标记阶段如果产生新的垃圾，cms无法对这些垃圾进行标记，会导致这些垃圾无法及时的被回收）。</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器。</p>
</li>
</ul>
<h3 id="G1回收器：区域分代化"><a href="#G1回收器：区域分代化" class="headerlink" title="G1回收器：区域分代化"></a>G1回收器：区域分代化</h3><ul>
<li><p>-XX:+UseG1GC：启用G1。</p>
</li>
<li><p>目标：延迟可控的情况下获取尽可能高的吞吐量。</p>
<ul>
<li>G1是一个并行回收器，它把堆内存分割为很多不相关的区域。使用不同的region来表示Eden区、幸存者0区、幸存者1区、老年代等。</li>
<li>G1有计划的避免在java堆中进行全区域的垃圾回收，G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间，所以给G1取一个名字：垃圾优先（Garbage First）。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>并行性：G1在回收期间，可以多个GC线程同时工作。此时用户线程stw。</li>
<li>并发性：G1部分工作能与用户线程同时执行。</li>
<li>分代收集：G1仍属于分代型垃圾收集器。但是不再要求整个Eden、年轻代、或者老年代都是连续的，也不再坚持固定大小和数量。它同时兼顾年轻代和老年代。</li>
<li>空间整合：内存是以region为基本单位的。region之间是复制算法，整体上看可以看作是标记-压缩算法。可以避免产生内存碎片。</li>
<li>可预测的时间停顿模型：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
</li>
<li><p>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p>
</li>
<li><p>Remembered Set：一个对象可能被不同区域region所引用。当有其它region指向本region时，记录其他region的引用。</p>
</li>
<li><p>G1垃圾回收的过程</p>
<ul>
<li>年轻代GC：①扫描根（包含RSet）；②更新RSet；③处理RSet；④复制对象；⑤处理引用。</li>
<li>并发标记过程：①初始标记（标记根节点直接可达的对象，会触发一次年轻代GC）；②根区域扫描（扫描survivor区能直达老年代的对象并标记被引用的对象）；③并发标记（若发现一个region区域全是垃圾，则直接回收）；④再次标记；⑤独占清理；⑥并发清理阶段。</li>
<li>混合回收：回收整个Yong Region和一部分Old Region。</li>
<li>如果上述方式不能正常工作，就会触发Full GC。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/4.jpg" alt="现状"></p>
<!--
|  垃圾收集器  |    分类    |    作用位置    |      使用算法      |     特点     |               适用场景               |
| :----------: | :--------: | :------------: | :----------------: | :----------: | :----------------------------------: |
|    Serial    |    串行    |     新生代     |      复制算法      | 响应速度优先 |         单cpu的client模式下          |
|    ParNew    |    并行    |     新生代     |      复制算法      | 响应速度优先 |  多cpu环境Server模式下与CMS配合使用  |
|   Parallel   |    并行    |     新生代     |      复制算法      |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|  Serial Old  |    串行    |     老年代     |   标记-压缩算法    | 响应速度优先 |          单cpu的client模式           |
| Parallel Old |    并行    |     老年代     |   标记-压缩算法    |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|     CMS      |    并发    |     老年代     |   标记-清除算法    | 响应速度优先 |        适用于互联网或B/S业务         |
|      G1      | 并发、并行 | 新生代、老年代 | 标记压缩、复制算法 | 响应速度优先 |            面向服务端应用            |
-->

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-垃圾回收相关概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/29/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-09-29T10:29:54.000Z" itemprop="datePublished">2020-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/29/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">垃圾回收相关概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><ul>
<li>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用会显示触发Full GC，但是该方法可能不是立刻就执行。</li>
</ul>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul>
<li>产生原因：没有空闲内存，并且垃圾收集器也无法提供更多内存。</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li>严格定义：对象不再被程序使用了，但是GC又不能回收他们的情况（仍然存在引用链）。</li>
<li>宽泛定义：一些不太好的实践会导致对象的生命周期变得很长，甚至导致OOM，也叫宽泛意义上的内存泄漏。</li>
</ul>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul>
<li>程序执行时并非在所有的地方都能停下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”（safepoint）。</li>
<li>如何在GC发生时，检测所有的程序都跑到最近的安全点停顿下来了呢 –&gt; 主动式中断：设置一个中断标志，各个线程运行到safe point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><ul>
<li>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。</li>
<li>可以应对处于sleep或者blocked状态的线程，这时候线程无法响应jvm的中断请求，“走”到安全点去中断挂起。</li>
<li>当程序运行到safe region的代码时，首先标识已经进入了safe region，如果这段时间发生了gc，jvm会忽略标识为safe region状态的线程。</li>
<li>当线程即将离开safe region时，会检测jvm是否已经完成了gc，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开safe region的信号为止。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><strong>强引用</strong>：类似“Object object=new Object()”这类的引用，只要强引用还存在，就永不回收。</p>
</li>
<li><p><strong>软引用</strong>：内存不足才回收。</p>
</li>
<li><p><strong>弱引用</strong>：发现即回收。</p>
</li>
<li><p><strong>虚引用</strong>：对象回收跟踪。</p>
<ul>
<li>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get方法来获取对象时，总是null。</li>
<li>为一个对象设置虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。</li>
<li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知引用程序对象的回收情况。</li>
<li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明强引用</span></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//声明软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf=<span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">//声明弱引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr=<span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">//虚引用</span></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; rq=<span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pr=<span class="keyword">new</span> PhantomReference&lt;&gt;(obj,rq);</span><br></pre></td></tr></table></figure>

<h3 id="评估性能指标"><a href="#评估性能指标" class="headerlink" title="评估性能指标"></a>评估性能指标</h3><ul>
<li><strong>吞吐量</strong>：运行用户代码时间占总运行时间的比例。</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>内存占用：Java堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-垃圾回收算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-09-27T02:57:23.000Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">垃圾回收算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h3><ul>
<li><p><strong>引用计数器法</strong></p>
<ul>
<li>给一个对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</li>
<li>优点：实现简单，垃圾对象便于识别；判定效率高，回收没有延迟性。</li>
<li>缺点：需要单独的字段存储计数器，增加了存储空间的开销；每次赋值都要更新计数器，伴随着加减法的操作，增加了时间开销；引用计数器有一个严重的问题，即<strong>无法处理循环引用情况</strong>。这是一个致命缺陷，导致java在垃圾回收器中没有使用这类算法。</li>
</ul>
</li>
<li><p><strong>可达性分析算法</strong></p>
<ul>
<li>基本思路：以根对象集合（GC Roots）为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>
<li>GC Roots包括：①虚拟机栈中引用的对象；②类静态属性引用的对象；③方法区中常量引用的对象；④本地方法栈中（Native方法）引用的对象；⑤被synchronized持有的对象；⑥jvm内部的引用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><ul>
<li><p>垃圾回收之前总会调用finalize方法，该方法可以被重写：通常是在这个方法中进行一些资源释放和清理的工作。</p>
</li>
<li><p>不要主动调用该方法，该方法的执行时间是没有保障的，它完全由gc线程决定。垃圾回收机制会主动调用该方法。</p>
</li>
<li><p>finalize方法只能被调用一次。</p>
</li>
<li><p>对象的三种状态：可触及；可复活；不可触及。</p>
</li>
<li><p>判断一个对象是否可回收，至少经历两次标记过程：</p>
<ol>
<li>如果对象到gc roots没有引用链，则进行第一次标记</li>
<li>进行筛选，判断该对象是否有必要执行finalize方法：①如果对象没有重写finalize方法，或者finalize方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，该对象被判为不可及的；②如果对象重写了finalize方法且还未执行过，那么该对象将被插入到F-Queue队列中，由一个低优先级、虚拟机自动创建的Finalizer线程区执行它；③finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次标记，如果对象在finalize方法中重新与引用链上的任意一个对象建立了联系，那么在第二次标记时它将被移出“即将回收”的集合。之后，如果该对象再次出现没有引用存在的情况下，finalize方法不会再次调用，对象会直接变为不可及的状态。也就是说一个对象的finalize方法就被调用一次。</li>
</ol>
</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul>
<li><p><strong>标记-清除算法（Mark-Sweep）</strong></p>
<ul>
<li>执行过程：当堆中的有效内存空间被耗尽的时候，就会停止整个程序（STW），然后进行两项工作，第一项是标记，第二项是回收。</li>
<li>标记：从根节点开始，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>清除：对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有被标记为可达对象，则将其回收。</li>
<li>优点：实现简单。</li>
<li>缺点：效率不够高；导致STW；会导致内存空间不连续，产生内存碎片，需要维护一个空闲列表。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.jpg" alt="标记-清除算法"></p>
<ul>
<li><p><strong>复制算法</strong></p>
<ul>
<li>执行过程：将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还活着的对象复制到另外一块上面去，然后再把已使用过的内存空间一次清理掉。</li>
<li>优点：实现简单；运行高效，不会出现内存碎片。</li>
<li>缺点：需要两倍的内存空间。</li>
<li>适用场景：存活对象比较少，垃圾对象比较多的场景。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.jpg" alt="复制算法"></p>
<ul>
<li><strong>标记-压缩（整理）算法</strong><ul>
<li>执行过程：第一阶段和标记-清除算法一样，从根节点标记所有被引用的对象。第二阶段是将所有存活对象整理到内存的一端，按顺序排放。之后清理边界外的所有对象。</li>
<li>指针碰撞：如果内存空间以规整、有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫指针碰撞（Bump the Pointer）。</li>
<li>优点：解决了内存碎片化的问题；消除了复制算法中内存减半的问题。</li>
<li>缺点：效率低于复制算法和标记-清除算法；移动对象的同时，还要调整引用的地址；会导致stw。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.jpg" alt="标记-整理算法"></p>
<ul>
<li><p><strong>分代收集算法</strong></p>
<ul>
<li>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以提高回收效率。一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li>
</ul>
</li>
<li><p><strong>增量收集算法</strong></p>
<ul>
<li>如果一次将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成。</li>
<li>总的来说，增量收集算法的基础仍然是传统的标记-清除算法和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集器以分阶段的方式完成标记、清理和复制工作。</li>
<li>缺点：线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量下降。</li>
</ul>
</li>
<li><p><strong>分区算法</strong></p>
<ul>
<li>将堆空间划分为连续不同的小区间region，每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-String" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/String/" class="article-date">
  <time datetime="2020-09-25T13:17:32.000Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/String/">String</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><ul>
<li><p>String类的声明为final。</p>
</li>
<li><p>String实现了Serializable接口：表明字符串是支持序列化的。实现了Comparable接口：表面字符串是可以比较大小。</p>
</li>
<li><p>String再jdk8及以前使用 final char[] value存储字符串数据，jdk9改为byte[]。</p>
</li>
<li><p>String的字符串常量池是一个固定大小的hashtable，在jdk7中默认大小是60013，（jdk8中1009是可以设置的最小值），使用<b>-XX:StringTableSize=</b>可以设置StringTable的长度。如果字符串常量池中的字符串非常多，就可能会造成hash冲突，从而导致链表变得很长（链表长度大于8时会转化成红黑树），但还是会导致性能下降（比如在调用intern时）。</p>
</li>
<li><p>字符串的拼接操作</p>
<ul>
<li>常量与常量的拼接是放在String Pool中，原因是编译期优化。</li>
<li>只要其中有一个是变量，结果就放在堆中。变量拼接的原理是StringBuilder。</li>
<li>如果拼接的结果调用intern方法，则主动将常量池中还没有的字符串放入池中，并返回其地址（如果String Pool中有，则直接返回其地址），下面还要对intern进行讨论。</li>
</ul>
</li>
</ul>
<h3 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="字符串的拼接操作"></a>字符串的拼接操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s3=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s4=s1+s2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果被拼接的字符串中有变量，执行字符串拼接操作会进行如下几个步骤</span></span><br><span class="line"><span class="comment">①StringBuilder s=new StringBuilder();</span></span><br><span class="line"><span class="comment">②s.append(s1); s.append(s2);</span></span><br><span class="line"><span class="comment">③s.toString();</span></span><br><span class="line"><span class="comment">如果要被拼接的字符串中全是常量或者常量引用，则仍然使用编译器优化，不会涉及到上面三步。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(s4==s3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这两行代码输出的结果为什么是nullabc呢？一起来分析一下源码吧</span></span><br><span class="line">String s=<span class="keyword">null</span>+<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s);<span class="comment">//nullabc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder类，当传入一个对象时会将该对象转化成一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> append(String.valueOf(obj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//String类，当该对象为null时，会返回一个&quot;null&quot;字符串，否则返回该对象的toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="部分考点分析"><a href="#部分考点分析" class="headerlink" title="部分考点分析"></a>部分考点分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建了两个对象</span></span><br><span class="line"><span class="comment">对象1：new String(&quot;ab&quot;);</span></span><br><span class="line"><span class="comment">对象2：常量池中的&quot;ab&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建了6个对象</span></span><br><span class="line"><span class="comment">对象1：new StringBuilder();</span></span><br><span class="line"><span class="comment">对象2：new String(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">对象3：常量池中的&quot;a&quot;;</span></span><br><span class="line"><span class="comment">对象4：new String(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">对象5：常量池中的&quot;b&quot;;</span></span><br><span class="line"><span class="comment">对象6：当append操作结束后，会调用StringBuilder的toString方法，将StringBuilder对象转化为String对象，</span></span><br><span class="line"><span class="comment">	此时又发生了一次new的操作:new String(value, 0, count);</span></span><br><span class="line"><span class="comment">tips：这里虽然创建了6个对象，但实际上在常量池中并没有创建&quot;ab&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h3><p>从jdk7开始，当我们调用String对象的intern()方法：</p>
<ul>
<li>如果常量池中有这个字符串，则返回常量池中该串的地址。</li>
<li>如果常量池中没有该串，则会把<strong>对象的引用地址</strong>复制一份，放入常量池，并返回常量池中的引用地址。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">s1.intern();</span><br><span class="line">String s2=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//false;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是因为一个是堆中的对象，一个是常量池中的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">String s3=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(s3==s4);<span class="comment">//true(jdk7及以上版本的结果);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个是不是感觉很匪夷所思？</span></span><br><span class="line"><span class="comment">原因是在创建了s3之后，常量池中并没有&quot;ab&quot;这个对象，</span></span><br><span class="line"><span class="comment">而在执行s3.intern()后，常量池中多了一个指向堆中的对象的指针，</span></span><br><span class="line"><span class="comment">所以当执行s4=&quot;ab&quot;时，s4实际上也是指向了堆中创建的那个对象。</span></span><br><span class="line"><span class="comment">为什么这么做呢？指针才占4个字节，用指针省空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对象实例化及内存布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" class="article-date">
  <time datetime="2020-09-25T07:14:10.000Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">对象实例化及内存布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol>
<li><p>当遇到一条new指令时，首先判断能否在常量池中定位到一个类的符号应用，并检查这个符号引用代表的类是否加载、解析和初始化</p>
</li>
<li><p>为对象分配内存，对象所需的内存大小在类加载完后就可完全确定</p>
<ul>
<li>如果内存规整，指针碰撞。</li>
<li>如果内存不规整，虚拟机需要维护一个列表，空闲列表分配。</li>
</ul>
</li>
<li><p>处理并发安全问题</p>
<ul>
<li>采用cas失败重试</li>
<li>每个线程预先分配一块TLAB，通过-XX:+/-UseTLAB参数来设置。</li>
</ul>
</li>
<li><p>对象属性初始化，即所有属性设置0值。</p>
</li>
<li><p>设置对象的对象头。</p>
</li>
<li><p>属性的显式初始化、代码块中初始化、执行init方法进行初始化。</p>
</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><ol>
<li><p>对象头，包括如下信息：</p>
<ul>
<li>运行时元数据：哈希值，gc分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳。</li>
<li>类型指针：指向类元数据的指针，确定该对象是哪个类的实例。</li>
<li>如果是数组，还需记录数组的长度。</li>
</ul>
</li>
<li><p>实例数据：它是真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）。</p>
<ul>
<li>规则：相同宽度的字段总是被分配在一起；父类定义的变量会出现在子类之前；如果compactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙。</li>
</ul>
</li>
<li><p>对齐填充</p>
<ul>
<li>仅仅起着占位符的作用，hotspot虚拟机要求任何对象的大小都必须是8字节的整数倍。</li>
</ul>
</li>
</ol>
<p><img src="/img/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E5%8A%9B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/1.jpg" alt="内存布局"></p>
<h3 id="访问定位"><a href="#访问定位" class="headerlink" title="访问定位"></a>访问定位</h3><ul>
<li>直接指针</li>
<li>句柄访问<ul>
<li>java堆中会划分出一块内存来作为句柄池，引用中存放的就是对象的句柄地址，句柄中包含了对象实例数据的指针和对象类型的指针。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-观察者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-09-25T01:34:02.000Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/25/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>定义：对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，能够自动通知其他关联对象，自动刷新对象状态。</li>
<li>Observer模式提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。</li>
</ul>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/img/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.jpg" alt="观察者模式"></p>
<ul>
<li>简单解释一下：在Subject类中维护了一个Observer对象列表，通过调用Subject的Attach方法将对象加入该列表，调用Detach将对象从该列表中移除。Subject中某些事件发生改变时，就会调用Notify方法。Notify方法中有一个循环，它会调用所有在列表中的对象的Update方法，达到通知的目的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-抽象工厂" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" class="article-date">
  <time datetime="2020-09-22T13:16:25.000Z" itemprop="datePublished">2020-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">抽象工厂</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无序指定他们具体的类。</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul>
<li>一系列相互依赖对象的创建。比如servlet使用 mysql对数据库处理的对象 或者 sqlserver对数据库处理的对象 ，由于mysql对应的类是不能使用sqlserver对应的类的，所以在这里我们就可以使用抽象工厂创建对象。</li>
<li>主要在于应对对“新系列”的需求变动。缺点在于难以应对“新对象”的需求变动。</li>
</ul>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/img/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/1.jpg" alt="抽象工厂类图"></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-工厂方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2020-09-22T12:44:45.000Z" itemprop="datePublished">2020-09-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/">工厂方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使得一个类的实例化延迟。</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul>
<li>使用new违背了依赖倒置原则，导致程序间的紧耦合。</li>
<li>该模式隔离了对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合（new）会导致软件的脆弱。</li>
<li>通过面向对象的手法，将所要创建对象的工作延迟到了子类。从而实现了一种扩展的策略（而非更改），较好的解决了这种紧耦合的关系。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表所有车</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比亚迪</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Biyadi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;比亚迪run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//奥迪</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aodi</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奥迪run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiyadiCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Biyadi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AodiCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Aodi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">(CarFactory carFactory)</span></span>&#123;</span><br><span class="line">	<span class="comment">//我开什么车去旅游全凭其他人给我什么车，假如公司有钱了，可能给我传递了更好的车</span></span><br><span class="line">    Car car=carFactory.createCar();</span><br><span class="line">    car.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*虽然可能还是会有依赖，但是在本实现中依赖基本上已经消失了</span></span><br><span class="line"><span class="comment">其实依赖不可能完全消失，我们使用模式的时候可能只是将散落在程序各个部分的依赖都集中起来*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//我只能开比亚迪去旅游，不能被更改</span></span><br><span class="line">    Car car=<span class="keyword">new</span> BiyadiCar();</span><br><span class="line">    car.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-装饰模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-09-21T13:51:40.000Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">装饰模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数）。</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul>
<li>java中的各种包装流就是用的装饰模式。</li>
<li>使用组合代替了不好的继承，使类的数量大大大的减少。</li>
<li>解决主体类在多个方向上的扩展功能。</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>有一个类叫OutputStream，其完成一个打印的功能。</p>
<p>现在A想对该类进行扩充，使其有缓冲的功能。</p>
<p>B也想对该类进行扩充，使其输出更加安全。</p>
<p>C也想对该类进行扩充，使其输出到文件中。</p>
<p>这我们都可以通过类继承来完成，并且看上去似乎也没有什么问题。但是假如D也想对该类进行缓冲，使其既有缓冲，又更安全，这时候再使用类继承就不合适了。</p>
<p>此时我们可以使用装饰模式来解决该问题。</p>
<p><img src="/img/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/1.jpg" alt="类图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OutputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteOutputStream</span> <span class="keyword">implements</span> <span class="title">OutputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装饰器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">OutputStream</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> OutputStream  outputStream;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(OutputStream outputStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outputStream=outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        outputStream.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓冲</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStream</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream outputStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am BufferedOutputStream&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecureOutputStream</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecureOutputStream</span><span class="params">(OutputStream outputStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am SecureOutputStream&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出到文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileOutputStream</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(OutputStream outputStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am FileOutputStream&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-策略模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-09-21T11:58:26.000Z" itemprop="datePublished">2020-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>定义：定义一系列算法，把他们一个个封装起来，并且使它们可以互相替换（变化），该模式使得算法可独立于使用他的客户程序而变化。</li>
<li>在软件构建过程中，某些对象使用的算法可能多种多样，策略模式做到了运行时根据需要透明的更改对象的算法，将对象与自身解耦。</li>
<li>比如税率，如果要求一个程序支持多国税率，可以使用if-else语句。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sale</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d=xxx;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span>(tax==ChineseTax)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tax==AmericeTax)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;elseif(tax==JapanTax)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<ul>
<li>但是如果后期需要加上其他国家的税率，就要修改程序，违背了开闭原则。此时可以使用策略模式。实现如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tax</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseTax</span> <span class="keyword">implements</span> <span class="title">Tax</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AmericaTax</span> <span class="keyword">implements</span> <span class="title">Tax</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sale</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Tax tax;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sale</span><span class="params">(Tax tax)</span></span>&#123;<span class="keyword">this</span>.tax=tax;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">buySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d=xxx;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        tax.calculate(d);<span class="comment">//替换掉先前的if-else</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">Next</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/web/">web</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/python/django/">django</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/http/">http</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse/">clickhouse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/26/equals/">equals</a>
          </li>
        
          <li>
            <a href="/2021/04/23/maven-dependency-scope/">maven-dependency-scope</a>
          </li>
        
          <li>
            <a href="/2021/04/19/%E6%89%A7%E8%A1%8Cssh%E5%91%BD%E4%BB%A4/">执行ssh命令</a>
          </li>
        
          <li>
            <a href="/2021/04/02/mybatis%E5%85%A5%E9%97%A8/">mybatis入门</a>
          </li>
        
          <li>
            <a href="/2021/03/27/zookeeper%E8%B5%B7%E6%AD%A5/">zookeeper起步</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 小象<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>