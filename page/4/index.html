<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>小象のblog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="小象のblog">
<meta property="og:url" content="https://xiaoxiangxiong.gitee.io/page/4/index.html">
<meta property="og:site_name" content="小象のblog">
<meta property="og:description" content="记录学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="小象">
<meta property="article:tag" content="xiaoxiang,小象のblog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小象のblog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="mheader">
    <div class="mtitle-wrap">
        <a href="/" class="mtitle">小象のblog</a>
		<a href="/archives/" class="msubtitle">概览</a>
		<a href="http://xiaoxiang.space" target="_self" class="msubtitle">说点什么</a>
    </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-join和park" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/19/join%E5%92%8Cpark/" class="article-date">
  <time datetime="2020-11-19T07:48:31.000Z" itemprop="datePublished">2020-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/19/join%E5%92%8Cpark/">join和park</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="join源码分析"><a href="#join源码分析" class="headerlink" title="join源码分析"></a>join源码分析</h3><ul>
<li>join()是等待一个线程运行结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//底层是使用wait()实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();<span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;<span class="comment">//已经等待的时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;<span class="comment">//参数为0时会一直等待线程结束</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="comment">//防止虚假唤醒，因为wait会被notify和notifyAll唤醒</span></span><br><span class="line">                <span class="comment">//唤醒后需要等待的时间是millis减去已经等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="park"><a href="#park" class="headerlink" title="park"></a>park</h3><ul>
<li>LockSupport.park();//暂停当前线程</li>
<li>LockSupport.unpark(暂停线程对象);//恢复某个线程的运行</li>
<li>对应的线程状态还是wait状态</li>
<li>unpark可以在park之前执行，仍然可以恢复线程的执行</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-桥模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/20/%E6%A1%A5%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-10-20T11:59:05.000Z" itemprop="datePublished">2020-10-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/20/%E6%A1%A5%E6%A8%A1%E5%BC%8F/">桥模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>模式定义：将抽象与实现分离，使它们都可以独立地变化。</li>
<li>应用场景：两个非常强的变化维度。</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="/img/%E6%A1%A5%E6%A8%A1%E5%BC%8F/1.jpg" alt="场景"></p>
<ol>
<li><p>分析一下，首先会创建1个电脑类，然后创建3个电脑的子类（即电脑的类型），再创建3x3个子类。假设有n种电脑类型，m种电脑品牌，那么产生的类的数量为<strong>1+n+n</strong>x<strong>m</strong>。</p>
</li>
<li><p>如果再加一个电脑品牌acer，则需要再添加三个类，即acer台式机、acer笔记本、acer平板。显然这种方式产生的类的数量非常多。</p>
</li>
<li><p>此外，这个实现违背了单一职责原则，类中出现了两个变化（电脑类型和品牌）。</p>
</li>
<li><p>解决办法：将类型写成一个抽象类，将品牌写成一个抽象类。通过一个”桥”将他们联系起来。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//品牌类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dell</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过类组合来替代类继承</span></span><br><span class="line">    <span class="keyword">protected</span> Brand brand;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Brand brand)</span></span>&#123;<span class="keyword">this</span>.brand=brand;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desktop</span><span class="params">(Brand brand)</span></span>&#123;<span class="keyword">super</span>(brand);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(Brand brand)</span></span>&#123;<span class="keyword">super</span>(brand);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pad</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pad</span><span class="params">(Brand brand)</span></span>&#123;<span class="keyword">super</span>(brand);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过上面的修改，类的数量变成了<strong>1+n+m</strong>。</li>
<li>在这里我理解的抽象是Brand，实现指的是Computer和Computer的子类。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/13/synchronized/" class="article-date">
  <time datetime="2020-10-13T10:10:25.000Z" itemprop="datePublished">2020-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/13/synchronized/">synchronized</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul>
<li>使用场景：如果一个对象虽然有多线程访问，但多线程的访问时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</li>
<li>使用线程的栈中的锁记录充当锁。</li>
<li>轻量级锁对使用者是透明的，即语法仍然是synchronized。</li>
<li>轻量级锁在没有竞争时，每次重入仍需要执行CAS操作。</li>
</ul>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><ul>
<li>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</li>
</ul>
<h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><ul>
<li>重量级锁竞争的时候，还可以使用自旋来优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</li>
</ul>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul>
<li>只有在第一次使用CAS将线程ID设置到对象头的Mark Word中，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</li>
<li>调用对象的hashCode()会禁用该对象的偏向锁；当有其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁；调用wait/notify会转化为重量级锁。</li>
<li>批量重偏向：如果对象虽然被多个线程访问，但是没有竞争，这时候偏向了t1的线程的对象仍有机会重新偏向t2，重偏向会重置对象的ThreadID。当撤销偏向锁<strong>阈值超过20次</strong>后，jvm会觉得：我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程。</li>
<li>批量撤销：当撤销偏向锁阈值超过40次后，jvm会觉得：自己确实错了，根本就不应该偏向。于是整个类的所有对象都会变成不可偏向的，新建的对象也是不可偏向的，针对类的优化。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Monitor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/12/Monitor/" class="article-date">
  <time datetime="2020-10-12T11:18:56.000Z" itemprop="datePublished">2020-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/12/Monitor/">Monitor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>32位虚拟机下</p>
<ul>
<li>普通对象</li>
</ul>
<p><img src="/img/Monitor/1.jpg" alt="普通对象"></p>
<ul>
<li>数组对象</li>
</ul>
<p><img src="/img/Monitor/2.jpg" alt="数组对象"></p>
<ul>
<li>mark word结构</li>
</ul>
<p><img src="/img/Monitor/3.jpg" alt="mark word结构"></p>
<ul>
<li>64位虚拟机下mark word结构</li>
</ul>
<p><img src="/img/Monitor/4.jpg" alt="64位虚拟机下mark word结构"></p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><ul>
<li>每个java对象都可以关联一个monitor对象，monitor对象由操作系统提供。如果使用synchronized给对象上锁（重量级）后，该对象对象头的mark word中的数据就会清空（不包括标志位，但标志位会发生改变），然后指向一个monitor对象。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java线程的6种状态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/08/java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/" class="article-date">
  <time datetime="2020-10-08T13:28:45.000Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/08/java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/">java线程的6种状态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>操作系统层面线程有5种状态</p>
</li>
<li><p>在 java中，Thread.State 将线程分为六种状态</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程刚被创建，但是还没调用start方法</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该状态的线程在jvm中是执行状态，但是在操作系统中可能是在等待其他的资源。</span></span><br><span class="line"><span class="comment">         * 此状态涵盖了操作系统中的 运行态、就绪态、阻塞态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此状态的线程会等待一个monitor lock。</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock </span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling Object.wait</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * 以下方法可使线程进入此状态：</span></span><br><span class="line"><span class="comment">         * 	 Object.wait with no timeout</span></span><br><span class="line"><span class="comment">         * 	 Thread.join with no timeout </span></span><br><span class="line"><span class="comment">         * 	 LockSupport.park</span></span><br><span class="line"><span class="comment">         * 该状态的线程会等待其他线程通过特定的动作唤醒。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified(特定的) waiting time.</span></span><br><span class="line"><span class="comment">         * 以下方法可使线程进入此状态：</span></span><br><span class="line"><span class="comment">         * 	 Thread.sleep</span></span><br><span class="line"><span class="comment">         * 	 Object.wait with timeout</span></span><br><span class="line"><span class="comment">         * 	 Thread.join with timeout</span></span><br><span class="line"><span class="comment">         * 	 LockSupport.parkNanos</span></span><br><span class="line"><span class="comment">         * 	 LockSupport.parkUntil</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程已经完成了执行，终止了的状态。</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-并发相关信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/08/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/" class="article-date">
  <time datetime="2020-10-08T10:56:39.000Z" itemprop="datePublished">2020-10-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/08/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/">并发相关信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h3><ul>
<li><p>sleep：让当前线程休眠n毫秒，休眠时让出cpu的时间片给其他线程。</p>
</li>
<li><p>join：等待某个线程运行结束。</p>
</li>
<li><p>yield：提示线程调度器让出当前线程对 CPU的使用。</p>
</li>
<li><p>interrupt()：打断线程，可能会产生打断标记（看下面的介绍）。</p>
<ul>
<li>可以使用isInterrupted()判断线程是否被打断。</li>
<li>如果线程正在sleep、wait、join会导致被打断的线程抛出InterruptedException，并清除打断标记。</li>
<li>如果打断正在运行的线程，则会设置打断标记。</li>
<li>interrupted()方法能返回打断标记的状态，并将打断标记设置为假。</li>
</ul>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>同步：需要等待结果返回，才能继续运行就是同步。</li>
<li>异步：不需要等待结果返回，就能继续运行就是异步。</li>
</ul>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><p>String  Integer  StringBuffer  Random  Vector  Hashtable  java.util.concurrent</p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wait和notify" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/06/wait%E5%92%8Cnotify/" class="article-date">
  <time datetime="2020-10-06T11:40:01.000Z" itemprop="datePublished">2020-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/06/wait%E5%92%8Cnotify/">wait和notify</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>在调用wait方法时，线程必须要持有被调用对象的锁，当调用wait方法之后，线程就会释放掉该对象的锁。</li>
<li>在调用Thread类的sleep方法时，线程是<strong>不会释放掉对象的锁</strong>的。</li>
</ul>
<hr>
<ol>
<li>当调用wait方法时，首先要确保调用了wait方法的线程已经持有了对象的锁。</li>
<li>当调用了wait后，该线程就会释放掉这个对象的锁，然后进入等待状态，该线程进入对象的等待集合中（wait set）。</li>
<li>当线程调用了wait后进入到等待状态时，它就等待其他线程调用相同对象的notify和notifyAll方法来使得自己被唤醒。</li>
<li>调用wait方法的代码片段需要放在一个synchronized块或者被synchronized修饰的方法中。</li>
<li>当调用了对象的notify方法时，它会随机唤醒该对象等待集合中（wait set）的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁。</li>
<li>当调用对象的notifyAll方法时，它会唤醒该对象等待集合中（wait set）中所有的线程，这些线程被唤醒后，又会开始竞争对象的锁。</li>
<li>某一时刻，只有唯一的一个线程拥有对象的锁。</li>
</ol>
<h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><p>Demon对象有一个int类型的属性counter，该值初始为0；<br>创建四个线程，两个线程对该值增1，两个线程对该值减1；<br>输出counter每次变化后的结果，要求输出结果为1010101010…。</p>
<h5 id="包含counter的Demon类"><a href="#包含counter的Demon类" class="headerlink" title="包含counter的Demon类"></a>包含counter的Demon类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该对象提供加1和减1的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demon</span></span>&#123;</span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//对方法加锁，当一个线程要调用该方法时，需要先获取该对象的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123;<span class="comment">//counter加1</span></span><br><span class="line">        <span class="comment">//此处必须使用while而不是if，防止被其他不相关的线程唤醒</span></span><br><span class="line">        <span class="keyword">while</span>(counter!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.print(counter);</span><br><span class="line">        <span class="comment">/*此处必须使用notifyAll，notify会从等待队列中</span></span><br><span class="line"><span class="comment">        随机选择一个线程唤醒，可能会导致程序一直阻塞*/</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//counter减1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(counter!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.print(counter);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键代码如上，剩余的代码也都比较简单，就省略了。如果你需要所有代码，可以通过<code>ctrl+u</code>查看网页源代码，并使用<code>ctrl+f</code>快捷键搜索”黑魔仙变身”即可找到完整代码。手机需要使用能查看网页源代码的浏览器，如via等。</strong></p>
<!--
//黑魔仙变身
//该对象提供加1和减1的操作
class Demon{
    //counter
    private int counter=0;
    //对方法加锁，当一个线程要调用该方法时，需要先获取该对象的锁
    public synchronized void inc(){//counter加1
        //此处必须使用while而不是if，防止被其他不相关的线程唤醒
        while(counter!=0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        counter++;
        System.out.print(counter);
        /*此处必须使用notifyAll，notify会从等待队列中
        随机选择一个线程唤醒，可能会导致程序一直阻塞*/
        notifyAll();
    }
    //counter减1
    public synchronized void dec(){
        while(counter!=1){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        counter--;
        System.out.print(counter);
        notifyAll();
    }
}
//执行counter++
class IncThread implements Runnable{
    private Demon demon;
    public IncThread(Demon demon){
        this.demon=demon;
    }
    //实现Runnable的run方法
    public void run() {
        for(int i=0;i<30;i++) {
            demon.inc();
        }
    }
}
//执行counter--
class DecThread implements Runnable{
    private Demon demon;
    public DecThread(Demon demon){
        this.demon=demon;
    }
    public void run() {
        for(int i=0;i<30;i++) {
            demon.dec();
        }
    }
}
//测试类
public class test {
    public static void main(String[] args) throws InterruptedException {
        Demon demon=new Demon();
        Thread t1=new Thread(new IncThread(demon));
        Thread t2=new Thread(new IncThread(demon));
        Thread t3=new Thread(new DecThread(demon));
        Thread t4=new Thread(new DecThread(demon));
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
-->
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-垃圾回收器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/30/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="article-date">
  <time datetime="2020-09-30T07:07:07.000Z" itemprop="datePublished">2020-09-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/30/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">垃圾回收器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>-XX:+PrintCommandLineFlags</strong>：查看命令行参数（可打印出使用的是哪个垃圾回收器）。</p>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/3.jpg" alt="垃圾收集器"></p>
<h3 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h3><ul>
<li><p>Client模式下默认的新生代垃圾收集器。</p>
</li>
<li><p>Serial收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</p>
</li>
<li><p>Serial Old-对应的老年代垃圾收集器，同样采用串行回收和“Stop-The-World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>Serial Old是Client模式下默认的老年代的垃圾收集器。</li>
<li>Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用；②作为老年代CMS收集器的后备垃圾收集方案。</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，在它进行垃圾收集时，必须停掉其他所有的工作线程，直到它收集结束。</p>
</li>
<li><p>-XX:+UseSerialGC：指定新生代Serial，老年代Serial Old GC。</p>
</li>
</ul>
<h3 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h3><ul>
<li><p>多线程的Serial。</p>
</li>
<li><p>-XX:+UseParNewGC：指定年轻代ParNew，不影响老年代。</p>
</li>
<li><p>-XX:ParallelGCThreads：限制线程数量，默认开启与cpu数据相同的线程数。</p>
</li>
</ul>
<h3 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h3><ul>
<li><p>同样采用并行回收、复制算法、STW机制。</p>
</li>
<li><p>Parallel Scavenge收集器的目标是达到一个可控的吞吐量，它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li><p>自适应调节机制也是Parallel Scavenge与ParNew的一个重要区别。</p>
</li>
<li><p>高吞吐量可以高效的利用cpu时间，尽快的完成程序的运算任务。<strong>主要用于在后台运算而不需要太多交互的任务</strong>。</p>
</li>
<li><p>应用场景：执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel Old：老年代垃圾收集器，采用标记-压缩算法、并行回收、STW机制。</p>
</li>
<li><p>-XX:+UseParallelGC：手动指定年轻代使用Parallel；-XX:+UserParallelOldGC：手动指定老年代。这两个参数，当指定一个，另一个也会被开启。</p>
</li>
<li><p>-XX:ParallelGCThreads：设置年轻代并行的线程数。</p>
</li>
<li><p>-XX:+UseAdaptiveSizePolicy：设置Parallel收集器具有自适应调节策列。</p>
</li>
</ul>
<h3 id="CMS回收器：低延迟-Concurrent-Mark-Sweep"><a href="#CMS回收器：低延迟-Concurrent-Mark-Sweep" class="headerlink" title="CMS回收器：低延迟(Concurrent-Mark-Sweep)"></a>CMS回收器：低延迟(Concurrent-Mark-Sweep)</h3><ul>
<li><p>HotSpot虚拟机中第一款真正意义上的并发收集器，实现了让垃圾收集线程与用户线程同时执行。</p>
</li>
<li><p>采用标记清除算法，也会导致stw。</p>
</li>
<li><p>运行过程：</p>
<ul>
<li>初始标记：仅标记GC Roots能直接关联到的对象。速度很快，需要stw。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程。</li>
<li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的stw一般会比初始标记稍长一些。</li>
<li>并发清除：清理标记阶段判断已经死亡的对象，释放内存空间。这个阶段可与用户线程并发。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/2.jpg" alt="cms"></p>
<ul>
<li><p>由于在垃圾收集阶段用户线程仍在执行，所以在<strong>CMS回收过程中，要保证应用程序线程有足够的内存可用</strong>。因此，CMS收集器不能像别的收集器一样等到老年代几乎完全填满了才进行垃圾回收，而是在堆内存达到某一个阈值时，便开始进行回收。当CMS运行期间，内存无法满足程序要求，这时虚拟机会启用预备方案：临时使用Serial Old进行垃圾回收。</p>
</li>
<li><p>CMS采用标记-清除算法，只能采用空闲列表进行内存分配。</p>
</li>
<li><p>优点：低延迟，并发收集。</p>
</li>
<li><p>缺点：产生内存碎片；对cpu资源非常敏感，因为占用了一部分线程，会导致吞吐量降低；无法处理浮动垃圾（并发标记阶段如果产生新的垃圾，cms无法对这些垃圾进行标记，会导致这些垃圾无法及时的被回收）。</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器。</p>
</li>
</ul>
<h3 id="G1回收器：区域分代化"><a href="#G1回收器：区域分代化" class="headerlink" title="G1回收器：区域分代化"></a>G1回收器：区域分代化</h3><ul>
<li><p>-XX:+UseG1GC：启用G1。</p>
</li>
<li><p>目标：延迟可控的情况下获取尽可能高的吞吐量。</p>
<ul>
<li>G1是一个并行回收器，它把堆内存分割为很多不相关的区域。使用不同的region来表示Eden区、幸存者0区、幸存者1区、老年代等。</li>
<li>G1有计划的避免在java堆中进行全区域的垃圾回收，G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间，所以给G1取一个名字：垃圾优先（Garbage First）。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>并行性：G1在回收期间，可以多个GC线程同时工作。此时用户线程stw。</li>
<li>并发性：G1部分工作能与用户线程同时执行。</li>
<li>分代收集：G1仍属于分代型垃圾收集器。但是不再要求整个Eden、年轻代、或者老年代都是连续的，也不再坚持固定大小和数量。它同时兼顾年轻代和老年代。</li>
<li>空间整合：内存是以region为基本单位的。region之间是复制算法，整体上看可以看作是标记-压缩算法。可以避免产生内存碎片。</li>
<li>可预测的时间停顿模型：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
</li>
<li><p>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p>
</li>
<li><p>Remembered Set：一个对象可能被不同区域region所引用。当有其它region指向本region时，记录其他region的引用。</p>
</li>
<li><p>G1垃圾回收的过程</p>
<ul>
<li>年轻代GC：①扫描根（包含RSet）；②更新RSet；③处理RSet；④复制对象；⑤处理引用。</li>
<li>并发标记过程：①初始标记（标记根节点直接可达的对象，会触发一次年轻代GC）；②根区域扫描（扫描survivor区能直达老年代的对象并标记被引用的对象）；③并发标记（若发现一个region区域全是垃圾，则直接回收）；④再次标记；⑤独占清理；⑥并发清理阶段。</li>
<li>混合回收：回收整个Yong Region和一部分Old Region。</li>
<li>如果上述方式不能正常工作，就会触发Full GC。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/4.jpg" alt="现状"></p>
<!--
|  垃圾收集器  |    分类    |    作用位置    |      使用算法      |     特点     |               适用场景               |
| :----------: | :--------: | :------------: | :----------------: | :----------: | :----------------------------------: |
|    Serial    |    串行    |     新生代     |      复制算法      | 响应速度优先 |         单cpu的client模式下          |
|    ParNew    |    并行    |     新生代     |      复制算法      | 响应速度优先 |  多cpu环境Server模式下与CMS配合使用  |
|   Parallel   |    并行    |     新生代     |      复制算法      |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|  Serial Old  |    串行    |     老年代     |   标记-压缩算法    | 响应速度优先 |          单cpu的client模式           |
| Parallel Old |    并行    |     老年代     |   标记-压缩算法    |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|     CMS      |    并发    |     老年代     |   标记-清除算法    | 响应速度优先 |        适用于互联网或B/S业务         |
|      G1      | 并发、并行 | 新生代、老年代 | 标记压缩、复制算法 | 响应速度优先 |            面向服务端应用            |
-->

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-垃圾回收相关概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/29/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-09-29T10:29:54.000Z" itemprop="datePublished">2020-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/29/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">垃圾回收相关概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><ul>
<li>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用会显示触发Full GC，但是该方法可能不是立刻就执行。</li>
</ul>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul>
<li>产生原因：没有空闲内存，并且垃圾收集器也无法提供更多内存。</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li>严格定义：对象不再被程序使用了，但是GC又不能回收他们的情况（仍然存在引用链）。</li>
<li>宽泛定义：一些不太好的实践会导致对象的生命周期变得很长，甚至导致OOM，也叫宽泛意义上的内存泄漏。</li>
</ul>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul>
<li>程序执行时并非在所有的地方都能停下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”（safepoint）。</li>
<li>如何在GC发生时，检测所有的程序都跑到最近的安全点停顿下来了呢 –&gt; 主动式中断：设置一个中断标志，各个线程运行到safe point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><ul>
<li>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。</li>
<li>可以应对处于sleep或者blocked状态的线程，这时候线程无法响应jvm的中断请求，“走”到安全点去中断挂起。</li>
<li>当程序运行到safe region的代码时，首先标识已经进入了safe region，如果这段时间发生了gc，jvm会忽略标识为safe region状态的线程。</li>
<li>当线程即将离开safe region时，会检测jvm是否已经完成了gc，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开safe region的信号为止。</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><strong>强引用</strong>：类似“Object object=new Object()”这类的引用，只要强引用还存在，就永不回收。</p>
</li>
<li><p><strong>软引用</strong>：内存不足才回收。</p>
</li>
<li><p><strong>弱引用</strong>：发现即回收。</p>
</li>
<li><p><strong>虚引用</strong>：对象回收跟踪。</p>
<ul>
<li>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get方法来获取对象时，总是null。</li>
<li>为一个对象设置虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。</li>
<li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知引用程序对象的回收情况。</li>
<li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明强引用</span></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//声明软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf=<span class="keyword">new</span> SoftReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">//声明弱引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr=<span class="keyword">new</span> WeakReference&lt;Object&gt;(<span class="keyword">new</span> Object());</span><br><span class="line"><span class="comment">//虚引用</span></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue&lt;Object&gt; rq=<span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; pr=<span class="keyword">new</span> PhantomReference&lt;&gt;(obj,rq);</span><br></pre></td></tr></table></figure>

<h3 id="评估性能指标"><a href="#评估性能指标" class="headerlink" title="评估性能指标"></a>评估性能指标</h3><ul>
<li><strong>吞吐量</strong>：运行用户代码时间占总运行时间的比例。</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>内存占用：Java堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-垃圾回收算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-09-27T02:57:23.000Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jvm/">jvm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">垃圾回收算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h3><ul>
<li><p><strong>引用计数器法</strong></p>
<ul>
<li>给一个对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</li>
<li>优点：实现简单，垃圾对象便于识别；判定效率高，回收没有延迟性。</li>
<li>缺点：需要单独的字段存储计数器，增加了存储空间的开销；每次赋值都要更新计数器，伴随着加减法的操作，增加了时间开销；引用计数器有一个严重的问题，即<strong>无法处理循环引用情况</strong>。这是一个致命缺陷，导致java在垃圾回收器中没有使用这类算法。</li>
</ul>
</li>
<li><p><strong>可达性分析算法</strong></p>
<ul>
<li>基本思路：以根对象集合（GC Roots）为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>
<li>GC Roots包括：①虚拟机栈中引用的对象；②类静态属性引用的对象；③方法区中常量引用的对象；④本地方法栈中（Native方法）引用的对象；⑤被synchronized持有的对象；⑥jvm内部的引用。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><ul>
<li><p>垃圾回收之前总会调用finalize方法，该方法可以被重写：通常是在这个方法中进行一些资源释放和清理的工作。</p>
</li>
<li><p>不要主动调用该方法，该方法的执行时间是没有保障的，它完全由gc线程决定。垃圾回收机制会主动调用该方法。</p>
</li>
<li><p>finalize方法只能被调用一次。</p>
</li>
<li><p>对象的三种状态：可触及；可复活；不可触及。</p>
</li>
<li><p>判断一个对象是否可回收，至少经历两次标记过程：</p>
<ol>
<li>如果对象到gc roots没有引用链，则进行第一次标记</li>
<li>进行筛选，判断该对象是否有必要执行finalize方法：①如果对象没有重写finalize方法，或者finalize方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，该对象被判为不可及的；②如果对象重写了finalize方法且还未执行过，那么该对象将被插入到F-Queue队列中，由一个低优先级、虚拟机自动创建的Finalizer线程区执行它；③finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次标记，如果对象在finalize方法中重新与引用链上的任意一个对象建立了联系，那么在第二次标记时它将被移出“即将回收”的集合。之后，如果该对象再次出现没有引用存在的情况下，finalize方法不会再次调用，对象会直接变为不可及的状态。也就是说一个对象的finalize方法就被调用一次。</li>
</ol>
</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul>
<li><p><strong>标记-清除算法（Mark-Sweep）</strong></p>
<ul>
<li>执行过程：当堆中的有效内存空间被耗尽的时候，就会停止整个程序（STW），然后进行两项工作，第一项是标记，第二项是回收。</li>
<li>标记：从根节点开始，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li>
<li>清除：对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有被标记为可达对象，则将其回收。</li>
<li>优点：实现简单。</li>
<li>缺点：效率不够高；导致STW；会导致内存空间不连续，产生内存碎片，需要维护一个空闲列表。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.jpg" alt="标记-清除算法"></p>
<ul>
<li><p><strong>复制算法</strong></p>
<ul>
<li>执行过程：将可用内存按容量分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还活着的对象复制到另外一块上面去，然后再把已使用过的内存空间一次清理掉。</li>
<li>优点：实现简单；运行高效，不会出现内存碎片。</li>
<li>缺点：需要两倍的内存空间。</li>
<li>适用场景：存活对象比较少，垃圾对象比较多的场景。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.jpg" alt="复制算法"></p>
<ul>
<li><strong>标记-压缩（整理）算法</strong><ul>
<li>执行过程：第一阶段和标记-清除算法一样，从根节点标记所有被引用的对象。第二阶段是将所有存活对象整理到内存的一端，按顺序排放。之后清理边界外的所有对象。</li>
<li>指针碰撞：如果内存空间以规整、有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫指针碰撞（Bump the Pointer）。</li>
<li>优点：解决了内存碎片化的问题；消除了复制算法中内存减半的问题。</li>
<li>缺点：效率低于复制算法和标记-清除算法；移动对象的同时，还要调整引用的地址；会导致stw。</li>
</ul>
</li>
</ul>
<p><img src="/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.jpg" alt="标记-整理算法"></p>
<ul>
<li><p><strong>分代收集算法</strong></p>
<ul>
<li>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采用不同的收集方式，以提高回收效率。一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li>
</ul>
</li>
<li><p><strong>增量收集算法</strong></p>
<ul>
<li>如果一次将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成。</li>
<li>总的来说，增量收集算法的基础仍然是传统的标记-清除算法和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集器以分阶段的方式完成标记、清理和复制工作。</li>
<li>缺点：线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量下降。</li>
</ul>
</li>
<li><p><strong>分区算法</strong></p>
<ul>
<li>将堆空间划分为连续不同的小区间region，每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/java%E5%B9%B6%E5%8F%91/">java并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/web/">web</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/python/django/">django</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/http/">http</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhouse/">clickhouse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/">排序</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/02/mybatis%E5%85%A5%E9%97%A8/">mybatis入门</a>
          </li>
        
          <li>
            <a href="/2021/03/27/zookeeper%E8%B5%B7%E6%AD%A5/">zookeeper起步</a>
          </li>
        
          <li>
            <a href="/2021/03/25/clickhouse%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%87%BD%E6%95%B0/">clickhouse类型及函数</a>
          </li>
        
          <li>
            <a href="/2021/03/24/cors/">cors</a>
          </li>
        
          <li>
            <a href="/2021/03/22/android/">android</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 小象<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>